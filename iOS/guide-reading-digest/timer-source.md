# Timer sources

## 是什么

Timer sources 是同步地传递事件到线程中

## Timer source 并不是那么准时

虽然 Timer sources 的工作机制是定时发送通知来执行，但实际上，并不是实时的，即不那么准时

不准时的原因有下面的情况

- 假设某个 Timer 定义在 mode B 上，现在到点了，需要触发 Timer 执行方法 f, 但由于当前应用所在的 Run Loop mode 是 A, 所以 Timer 并不会触发执行 f. 只有等到应用的 Run Loop mode 切换到 B 时，才会触发 Timer 执行 f. 于是，造成了延时
- 假设某个 Timer 定义在 mode B 上，现在到点了，当前应用的 Run Loop mode 也处于 B, 但在本轮的循环中，正在执行了另一个事件处理，于是 Timer 不能触发执行方法 f. 只有等到下一个循环在触发执行 f. 于是，造成了延时

## Timer source 并不是想象中的重复触发

Timer 可以配置成在一定的时间间隔中重复触发

但要知道的是，这个时间间隔，是基于理想的时间间隔，而不是实际的时间间隔

> 用轮播图来做例子，我们需要 3 秒钟换一次
> 
> 理想的时间间隔，指的就是那 3 秒钟
> 实际的时间间隔，指的是 3 + n 秒钟
> 
> 在实际运行的过程中，可能有耗时操作 A ，造成当 3 秒钟到达的时候，A 还没有完成，阻止了轮播图的执行，在 3 + 1 秒的时候，A 完成了，轮播图可以执行了。但在下一次轮播图换图的时候，并不会补偿刚才延迟的 1 秒，而是在 6 秒的时候进行换图

当有一个或多个的计划调度错过了，后面并不会将前面错过的调度补偿回来，而只会触发一次

