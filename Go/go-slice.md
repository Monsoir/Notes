# 切片

## 写法

数组不能改变大小，而切片则为数组提供可灵活改变大小的选择

> 实际上，切片比数组更常用

```go
a[low : hight] // 前闭后开区间

a[1:4] // 包括 a[1], a[2], a[3]
```

可以直接创建切片

```go
[3]bool{true, true, false}

// 这两种写法其实是等效，先创建一个数组 A，然后创建一个切片引用了 A

[]bool{true ,true, false}
```

## 底层

- 切片只是数组元素的引用
- 切片本身不存储任何数据，只表示底层数组中的一段元素范围
- 因此，改变切片中的元素会同时改变底层数组中的元素

## 默认行为

切片的上界默认为 0, 下界默认为底层数组的长度

```go
var a [10]int

// 以下 4 种写法都是获得相同的切片
a[0:10]
a[:10]
a[0:]
a[:]
```

## 切片的长度与容量

长度：切片所包含的元素个数，可以通过 `len(s)` 来获取

容量：从切片的第一个元素开始，到此切片底层数组末尾的元素个数，可以通过 `cap(s)` 来获取

## 零值

- 切片零值为 `nil`
- `nil` 切片的长度和容量为 0, 且没有底层数组


## 使用 make 创建切片，创建动态数组

```go
var a = make([]int, 5) // len(a) = 5
```

创建一个元素为零值的数组，并将此数组的切片返回

---

指定切片的容量，需要传入第三个参数

```go
b := make([]int, 0, 5) // len(b) = 0, cap(b) = 5

b = b[:cap(b)] // len(b) = 5, cap(b) = 5
b = b[1:] // len(b) = 4, cap(b) = 4
```

## 追加元素

要向切片追加元素，需要使用 Go 提供的内置函数 `append`

> 注意是函数，而不是方法

```go
func append(s []T, a1, a2, ...)
```

- 第一个参数，被追加的切片
- 其余参数，追加到切片的元素
- 返回结果，一个包含原有切片元素与被追加元素的切片
- 当被追加切片的底层数组容量不够时，会自动分配一个容量更大的数组



